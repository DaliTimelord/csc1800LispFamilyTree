;;;; -*- Mode: Lisp; -*- 


(defstruct person 

  (parents nil)
  (children nil)
  (spouses nil)
  (name nil))


(defun storeperson (symbol-name struct family-tree)

  (if (not (gethash symbol-name family-tree))
      (setf (gethash symbol-name family-tree) struct))

  family-tree)



(defun personstruct (symbol-name family-tree)

  "Returns a structure of type person corresponding to the key SYMBOL-NAME in the hashtable FAMILY-TREE. If there is no one in the tree with the name in SYMBOL-NAME, returns NIL."

  (gethash symbol-name family-tree nil))



(defun ancestors (p tree)

  "Returns a list of symbol-names of all the ancestors of P in TREE. Does not remove any duplicated names!"

   (let ((parent1 (personstruct (first (person-parents p)) tree))

         (parent2 (personstruct (second (person-parents p)) tree)))

     (when parent1

         (append (list (person-name parent1) (person-name parent2))

                 (ancestors parent1 tree)

                 (ancestors parent2 tree)))))

(defun getsiblings (symbol-1 tree)
  (setf p1 (personstruct (first (person-parents (personstruct symbol-1 tree))) tree))
  (setf p2 (personstruct (second (person-parents (personstruct symbol-1 tree))) tree))
  (remove symbol-1 (remove-duplicates (append (person-children p1) (person-children p2)))))

(defun is-spouse (symbol-1 symbol-2 tree)
  (member symbol-1 (person-spouses (personstruct symbol-2 tree))))

(defun is-ancestor (symbol-1 symbol-2 tree)
  (member symbol-1 (person-spouses (personstruct symbol-2 tree))))

(defun is-child (symbol-1 symbol-2 tree)
  (member symbol-1 (person-children (personstruct symbol-2 tree))))

(defun is-cousin (symbol-1 symbol-2 tree)
  (member symbol-1 (person-spouses (personstruct symbol-2 tree))))


(defun family ()

  "This is the top-level function for the whole Lisp program."
  (setf tree (make-hash-table :size 1000 :test #'equal))
  (loop for line = (read *STANDARD-INPUT* nil nil)
        while line do (progn
                        (cond ((string= (first line) "W") 
                               (cond ((string= (second line) "SIBLING")
                                      (print (getsiblings (third line) tree)))
                                     ((string= (third line) "SPOUSE")
                                      (if (is-spouse (second line) (fourth line) tree)
                                          (print "Yes")
                                        (print "No")))))
                              ((string= (first line) "X")
                               (print (format nil "~{~A~^, ~}" line))
                               (cond ((string= (third line) "CHILD")
                                      (if (is-child (second line) (fourth line) tree)
                                          (print "Yes")
                                        (print "No")))
                                     ((string= (third line) "SPOUSE")
                                      (if (is-spouse (second line) (fourth line) tree)
                                          (print "Yes")
                                        (print "No")))))
                              ((string= (first line) "E")
                               (if (personstruct (second line) tree)
                                   (setf p1 (personstruct (second line) tree))
                                 (progn (setf p1 (make-person :name (second line)))
                                   (storeperson (person-name p1) p1 tree)))
                               (if (personstruct (third line) tree)
                                   (setf p2 (personstruct (third line) tree))
                                 (progn (setf p2 (make-person :name (third line)))
                                   (storeperson (person-name p2) p2 tree)))
                               (cond ((fourth line)
                                      (setf p3 (make-person :name (fourth line)
                                                            :parents (list (person-name p1) (person-name p2))))
                                      (storeperson (person-name p3) p3 tree)
                                      (setf (person-children p1) (append (person-children p1) (list (person-name p3))))
                                      (setf (person-children p2) (append (person-children p2) (list (person-name p3))))))

                               (cond ((not (member (person-name p2) (person-spouses p1)))
                                      (setf (person-spouses p1) (append (person-spouses p1) (list (person-name p3))))
                                      (setf (person-spouses p2) (append (person-spouses p2) (list (person-name p3)))))))))))

(let ((*STANDARD-INPUT* (open "C:\\Users\\Velociraptor 2.0\\Desktop\\lisp\\test.txt" :direction :input)))
  (family))
